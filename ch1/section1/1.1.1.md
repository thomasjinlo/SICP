# Exercises

## 1.1
10
12
8
3
4
a
b
19
#f
4
16
6
16

## 1.2
```scheme
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
    (* 3
       (- 6 2)
       (- 2 7)))
```

## 1.3
```scheme
(define (square x) (* x x))
(define (sos x y) (+ (square x) (square y)))
(define (sos* x y z) 
  (if (< x y)
      (if (< x z) (sos y z) (sos x y))
      (if (< y z) (sos x z) (sos x y))))
```

## 1.4
Sums the argument `a` with the absolute value of `b`.

## 1.5
If the interpreter was using applicative-order evaluation, the evaluation of `(test 0 (p))` would not terminate, because the procedure of `p` is `p` itself, causing an infinite recursion.

If the interpreter was using `normal-order` evaluation the interpreter would have evaluated to `0` and there would be no infinite recursion, because the parameter `y` will never get evaluated to `p`.

## 1.6
The `new-if` procedure evaluates not only the `predicate`, but also, the `then` and `else` arguments immediately. The issue arises when the `else` argument is evaluated, which in return calls the procedure `sqrt-iter` over again, with the unchanged `guess`. This means, no matter how close the guess is, as the `else` argument gets evaluated, their will be a recursive call to `sqrt-iter` leading to a never ending cycle, and thus, eventually  returning a stack overflow.

## 1.7
```scheme
(define (abs x) (if (< x 0) (- x) x))
(define (square x) (* x x))
(define (improve x guess)
  (/ (+ guess (/ x guess)) 2))

; the improved good-enough? procedure will be true when the absolute
; difference between the current and improved guess is minimal
(define (good-enough? x guess)
  (or (< (abs (- (improve x guess) guess)) 0.0001)
      (< (abs (- x (square guess))) 0.0001)))

(define (try x guess)
  (if (good-enough? x guess)
      guess
      (try x (improve x guess))))

(define (sqrt x) (try x (/ x 2)))
```
